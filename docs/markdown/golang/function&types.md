# 函数与类型

## 函数

这是定义一个函数最简单的格式：

```go
func functionName()
```

你可以在括号 `()` 中写入 0 个或多个函数的参数（使用逗号 `,` 分隔），**每个参数的名称后面必须紧跟着该参数的类型**。

函数里的代码（函数体）使用大括号 `{}` 括起来。

左大括号 `{` 必须与方法的声明放在同一行，这是编译器的**强制规定**，否则你在使用 gofmt 时就会出现错误提示：

```sh
build-error: syntax error: unexpected semicolon or newline before {
```

> （这是因为编译器会产生 func main() ; 这样的结果，很明显这错误的）  

**Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误**  
右大括号 `}` 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行：  

```go
func Sum(a, b int) int { return a + b }

```

对于大括号 `{}` 的使用规则在任何时候都是相同的（如：if 语句等）。

因此符合规范的函数一般写成如下的形式：

```go
func functionName(parameter_list) (return_value_list) {
   …
}

```

其中：

> * parameter_list 的形式为 (param1 type1, param2 type2, …)
> * return_value_list 的形式为 (ret1 type1, ret2 type2, …)

只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 [Pascal命名法]；

::: info Pascal命名法
指当变量名和函式名称是由二个或二个以上单词连结在一起，每个单词首字母大写。而构成的唯一识别字时，用以增加变量和函式的可读性。
:::

否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。

下面这一行调用了 `fmt` 包中的 `Println` 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 `\n` ：

```go
fmt.Println（"hello, world"）
```

当被调用函数的代码执行到结束符 `}` 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。

## 类型

可以包含数据的变量（或常量），可以使用不同的数据类型或类型来保存数据。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。

类型可以是基本类型，如： `int` 、 `float` 、 `bool` 、 `string`

结构化的（复合的），如： `struct` 、 `array` 、 `slice` 、 `map` 、 `channel`

只描述类型的行为的，如： `interface`

结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是 NULL 或 0）。值得注意的是，Go 语言中不存在类型继承。

函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如：

```go
func FunctionName (a typea, b typeb) typeFunc
```

你可以在函数体中的某处返回使用类型为 typeFunc 的变量 var： `return var`

一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 `()` 将它们括起来，如：

```go
func FunctionName (a typea, b typeb) (t1 type1, t2 type2)
```

返回值形式： `return var1, var2`

使用 `type` 关键字可以定义你自己的类型，你可能想要定义一个[结构体]，但是也可以定义一个已经存在的类型的别名，如：

```go
type IZ int
```

**这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。**

如果你有多个类型需要定义，可以使用因式分解关键字的方式，例如：

```go
type (
   IZ int
   FZ float64
   STR string
)
```

每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值的类型），因为 Go 语言是一种静态类型语言。

## 类型转换

在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 `Go` 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样(类型在这里的作用可以看作是一种函数):

```go{ }
valueOfTypeB = typeB(valueOfTypeA)
// 类型 B 的值 = 类型 B (类型 A 的值)
a := 5.0
b := int(a)
```

::: tip 需要注意的是
  但这只能在定义正确的情况下转换成功。  
  例如从一个取值范围较小的类型转换到一个取值范围较大的类型（例如将 int16 转换为 int32）。  
  当从一个取值范围较大的转换到取值范围较小的类型时（例如将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。  
  当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。  
:::

具有相同底层类型的变量之间可以相互转换：

```go{ }
var a IZ = 5
c := int(a)
d := IZ(c)
```
