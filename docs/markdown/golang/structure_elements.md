# Go程序的基本结构和要素

示例  

<<< @/markdown/golang/demo_Go/hellow_world.go#snippet{go}

## 包的概念、导入与可见性

包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。

如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 `.go` 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

你必须在源文件中非注释的第一行指明这个文件属于哪个包，如： `package main` 。 `package main` 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 `main` 的包。

一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 `package main` 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 `pack1` ，编译后产生的对象文件将会是 `pack1.a` 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。

## 标准库

在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。

在 Windows 下，标准库的位置在 Go 根目录下的子目录 `pkg\windows_386` 中

在 Linux 下，标准库在 Go 根目录下的子目录 `pkg\linux_amd64` 中

> （如果是安装的是 32 位，则在 `linux_386` 目录中）。

一般情况下，标准包会存放在 `$GOROOT/pkg/$GOOS_$GOARCH/` 目录下。

> Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。

::: info Tip
如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。

包的依赖关系决定了其构建顺序。

属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。
:::
**如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。**

Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .go 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。

如果 `A.go` 依赖 `B.go` ，而 `B.go` 又依赖 `C.go` ：

编译 `C.go` , `B.go` , 然后是 `A.go` .
为了编译 `A.go` , 编译器读取的是 `B.go` 而不是 `C.go`

这种机制对于编译大型的项目时可以显著地提升编译速度。

**每一段代码只会被编译一次**

一个 Go 程序是通过 `import` 关键字将一组包链接在一起。  

如果需要多个包，它们可以被分别导入：

```go
import "fmt"
import "os"
```

或：

```go
import "fmt"; import "os";
```

但是还有更短且更优雅的方法（被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义）：

```go
import (
	"fmt"
	"os"
)
```

它甚至还可以更短的形式，但使用 gofmt 后将会被强制换行：

```go
import ("fmt"; "os")
```

当你导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读。  

如果包名不是以 `.` 或 `/` 开头，如 `"fmt"` 或者 `"container/list"` ，则 Go 会在全局文件进行查找；

如果包名以 `./` 开头，则 Go 会在相对目录中查找；

如果包名以 `/` 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。

导入包即等同于包含了这个包的所有的代码对象。

除了符号 `_` ，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。

包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：

## 可见性规则

* 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就**可以被外部包的代码所使用（客户端程序需要先导入这个包）**，这被称为导出（像面向对象语言中的 public）；
  
* 标识符如果以小写字母开头，则**对包外是不可见的**，但是他们在整个**包的内部是可见并且可用的**（像面向对象语言中的 private ）。

（大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。

因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。

假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用： `pack1.Thing` （pack1 在这里是不可以省略的）。

因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 `pack1.Thing` 和 `pack2.Thing` 。

下面的代码展示了如何使用包的别名：

```go
package main

import fm "fmt" // alias3

func main() {
   fm.Println("hello, world")
}
```

你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如： `import fm "fmt"` 。

::: warning 注意事项

如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 `imported and not used: os` ，这正是遵循了 Go 的格言：  

“没有不必要的代码！“
:::

## 包的分级声明和初始化

你可以在使用 `import` 导入包之后定义或声明 0 个或多个常量（const）、变量（var）和类型（type），这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用（如 gotemplate.go 源文件中的 c 和 v），然后声明一个或多个函数（func）。

## Go命名规范

干净、可读的代码和简洁性是 Go 追求的主要目标。

通过 gofmt 来强制实现统一的代码风格。  

Go 语言中对象的命名也应该是简洁且有意义的。

像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。  

名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。  

返回某个对象的函数或方法的名称一般都是使用名词，没有 `Get...` 之类的字符，如果是用于修改某个对象，则使用 `SetName`。  

有必须要的话可以使用大小写混合的方式，如 `MixedCaps` 或 `mixedCaps` ，而不是使用下划线来分割多个名称。
