# 变量和常量

声明[变量](#变量)的一般形式是使用 `var` 关键字： `var identifier type` 。

> 需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。

::: info Go 为什么要选择这么做呢？

* 1. 首先，它是为了避免像 C 语言中那样含糊不清的声明形式  
  * 例如：`int* a, b`; 。在这个例子中，只有 a 是指针而 b 不是。  
  * 如果你想要这两个变量都是指针，则需要将它们分开书写。  

* 2. 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。
:::

---

[常量](#常量)使用关键字 `const` 定义，用于存储不会改变的数据。

存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

常量的定义格式： `const identifier [type] = value` ，例如：

```go{ }
const Pi = 3.14159

```

## 类型推导

在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据**变量和常量**的值来推断其类型,例如：

> 这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程

```go{2,5 }
// 显式类型定义：
var name string = "pprof.cn" // [!code focus]
const sex int = 1
// 隐式类型定义：
var name = "pprof.cn" // [!code focus]
const sex = 1

```

不过自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型，例如：

```go{ }
var n int64 = 2
```

然而，`var a` 这种语法是不正确的，因为编译器没有任何可以用于自动推断类型的依据。

变量的类型也可以在运行时实现自动推断，例如：

```go{ }
var (
    HOME = os.Getenv("HOME")
    USER = os.Getenv("USER")
    GOROOT = os.Getenv("GOROOT")
)
```

---

## 变量常量命名规则

> * 1、变量名称必须由数字、字母、下划线组成。  
> * 2、标识符开头不能是数字。  
> * 3、标识符不能是保留字和关键字。  
> * 4、变量的名字是区分大小写的。
>   * 如: `age` 和 `Age` 是不同的变量。
>   * 在实际的运用中, 也建议, 不要用一个单词大小写区分两个变量。
> * 5、标识符(变量名称)一定要见名思意：变量名称建议用名词，方法名称建议用动词。
> * 6、变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如DNS）的时候，特有名词根据是否私有全部大写或小写。

::: warning 提示
  但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的**首字母也大写**
:::

## 作用域

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。

## 变量

程序运行过程中数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。

### 变量的类型

变量（Variable）的功能是存储数据。不同的变量保存数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整形、浮点型、布尔型等。

Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。

## 变量声明

Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。

Go语言的变量声明格式为：

```go{ }
var 变量名 变量类型
```

在 Go 中，则可以很轻松地将它们都声明为指针类型，同样的它也支持因式分解写法如下👇：

```go{ }
var a, b *int

var a int
var b bool
var str string

var (
    a int
    b bool
    str string
)
// 这种因式分解关键字的写法一般用于声明全局变量。
```

## 变量的初始化

Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如：  

`int` 为 `0` ， `float` 为 `0.0`

`str` 变量的默认值为空字符串

`bool` 变量默认为 `false`

切片、函数、指针变量的默认为 `nil`

变量可以编译期间就被赋值，赋值给变量使用运算符等号 `=` ，当然我们也可在声明变量的时候为其指定初始值。

变量初始化的标准格式如下：

```go
var 变量名 类型 = 表达式
```

举个例子：  

```go
var name string = "pprof.cn"  
var sex int = 1
```

或者一次初始化多个变量

```go
var name, sex = "pprof.cn", 1
```

### 短变量声明

在函数内部,可以使用更简略的 `:=` 方式声明并初始化变量,可以高效地创建一个新的变量。

```go
package main

import (
    "fmt"
)
// 全局变量m
var m = 100

func main() {
    n := 10
    m := 200 // 此处声明局部变量m
    fmt.Println(m, n)
}
```

::: danger 注意

* 只能被用在函数体内  
* 不可以用于全局变量的声明与赋值
* 不可以再次对于相同名称的变量使用初始化声明

```go{ }
a := 1000
a := 20 
//a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=
a := 20
// 但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值
```

:::

## 局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。

尽管变量的标识符必须是唯一的，但你可以在某个代码块的内层代码块中使用相同名称的变量，则此时外部的同名变量将会暂时隐藏（结束内部代码块的执行后隐藏的外部同名变量又会出现，而内部同名变量则被释放），你任何的操作都只会影响内部代码块的局部变量。

下面这个例子展示了如何通过 [runtime] 包在运行时获取所在的操作系统类型，以及如何通过 `os` 包中的函数 `os.Getenv()` 来获取环境变量中的值，并保存到 string 类型的局部变量 path 中。

[runtime]: ./other/runtime

```go{ }
package main

import (
    "fmt"
   "runtime"
    "os"
)

func main() {
    var goos string = runtime.GOOS
    fmt.Printf("The operating system is: %s\n", goos)
    path := os.Getenv("PATH")
    fmt.Printf("Path is %s\n", path)
}
```

如果你在 Windows 下运行这段代码，则会输出 `The operating system is: windows` 以及相应的环境变量的值；

如果你在 Linux 下运行这段代码，则会输出 `The operating system is: linux` 以及相应的的环境变量的值。

### 注意事项

如果你在定义变量 a 之前使用它，则会得到编译错误 `undefined: a`

如果你声明了一个局部变量a却没有在相同的代码块中使用它，同样会得到编译错误`a declared and not used`

## 匿名变量

在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如：

```go
func foo() (int, string) {
    return 10, "Q1mi"
}
func main() {
    x, _ := foo()
    _, y := foo()
    fmt.Println("x=", x)
    fmt.Println("y=", y)
}
```

匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)

注意事项：

* 函数外的每个语句都必须以关键字开始（var、const、func等）

* _多用于占位，表示忽略值。

## 常量

相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。

```go
const pi = 3.1415
const e = 2.7182
```

声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。

多个常量也可以一起声明：

```go
const (
        pi = 3.1415
        e = 2.7182
      )
```

const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：

```go
const (
        n1 = 100
        n2
        n3
      )
```

上面示例中，常量n1、n2、n3的值都是100

## iota

`iota` 是go语言的常量计算器，只能在常量得表达式中使用。 `iota` 在 `const` 关键字出现将被置为 `0` 。 `const` 中每新增 **一行** 常量声明将使 `iota` 计数一次（ `iota` 可以理解为 `const` 语句块中的行索引）。使用 `iota` 能简化定义，在定义枚举时很有用。

举个例子：

```go
const (
        n1 = iota //0
        n2        //1
        n3        //2
        n4        //3
      )
```

## 几个常见的iota示例

使用_跳过某些值

```go
const (
        n1 = iota //0
        n2        //1
        _
        n4        //3
      )
```

iota声明中间插队

```go
const (
  n1 = iota //0
  n2 = 100  //100
  n3 = iota //2
  n4        //3
)
const n5 = iota //0
const n6 = iota //0
```

定义数量级 （这里的<<表示左移操作，1<<10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2<<2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）

```go
const (
        _  = iota
        KB = 1 << (10 * iota)
        MB = 1 << (10 * iota)
        GB = 1 << (10 * iota)
        TB = 1 << (10 * iota)
        PB = 1 << (10 * iota)
      )

```

多个iota定义在一行

```go
const (
        a, b = iota + 1, iota + 2 //1,2
        c, d                      //2,3
        e, f                      //3,4
      )
```
